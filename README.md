# UniMUD

Low-level networking utilities for interacting with the [MUD v2](https://v2.mud.dev) framework in [Unity](https://unity3d.com).

If your goal is to just make a game, **you should not use UniMUD directly.** Instead, use the higher-level abstractions from (add link here).

## Getting Started

UniMUD is under active development. Expect the API to change.

### Installation

Add UniMUD to the Unity Package Manager via git url

```
https://github.com/emergenceland/unimud.git?path=Packages/UniMUD
```

### Setup

UniMUD looks for a NetworkManager instance in the scene. You should create an empty game object and attach the NetworkManager component (included with UniMUD) to it. The NetworkManager component has a few properties that you can must set:

- JSON RPC URL
- Websocket URL
- ChainID
- Contract Address (this is auto-populated in some templates)

As well as a few optional properties:

- Private Key (pk)
- Starting block number

You also need Nethereum bindings for your generated World contract. Bindings can be autogenerated for you in some templates, but you can also use any of these tools: [Nethereum Code Generation](https://docs.nethereum.com/en/latest/nethereum-code-generation/)

UniMUD currently does not implement a faucet service, so you must manually send funds to your address when deploying to a non-local chain (i.e. not Anvil).

## Example Usage

### Making transactions

```csharp
using IWorld.ContractDefinition;
using mud.Unity;
using UnityEngine;

async void Move(int x, int y)
{
	// The MoveFunction type comes from your autogenerated bindings
	// NetworkManager exposes a worldSend property that you can use to send transactions.
	// It takes care of gas and nonce management for you.
	// Make sure your MonoBehaviour is set up to handle async/await.
	await NetworkManager.Instance.worldSend.TxExecute<MoveFunction>(x, y);
}
```

### Representing State

UniMUD caches MUD v2 events in the client for you in a "datastore." You can access the datastore via the NetworkManager instance. The datastore keeps a collection of Records:

```csharp
class Record {
  public string table;
  public string key;
  public string attribute;
  public object value;
}
```

For example, records for an entity's Position might look like:

```json
[
  {
    "table": "Position",
    "key": "0x1234",
    "attribute": "x",
    "value": 1
  },
  {
    "table": "Position",
    "key": "0x1234",
    "attribute": "y",
    "value": 2
  },
  {
    "table": "Position",
    "key": "0x5678",
    "attribute": "x",
    "value": 3
  }
]
```

To fetch a record by key:

```csharp
IEnumerable GetMonstersWithKey(string monsterKey) {
	var ds = NetworkManager.Instance.ds;
	var monstersTable = new TableId("", "Monsters");

	// Returns an IEnumerable of matching Records
	return ds.GetRecordByKey(monstersTable, monsterKey);
}
```

### Reacting to Updates

The datastore exposes an Observable that you can subscribe to for updates. The Observable emits new Records that have been updated/created/deleted.

```csharp
using System;
using UniRx;
using mud.Client;
using mud.Unity;
using UnityEngine;

public class Health : MonoBehaviour
{
    private IDisposable _disposable = new();

    private void Awake()
    {
			_disposable = NetworkManager.Instance.ds
				.OnDataStoreUpdate.ObserveOnMainThread() // observe on main thread
				.Subscribe(OnHealthChange);
    }

    private void OnHealthChange(RecordUpdate update)
    {
      // update.Value is a tuple of (currentValue, previousValue)
      var currentValue = update.Value.Item1;
      var previousValue = update.Value.Item2;

      // Values are Dictionaries mapping string attributes to their values.
      // For example, if your mud config defines Health as:
      //  Health: {
      //    schema: {
      //      myHealthValue: "uint32",
      //      },
      //    }

      // Then the value will be a Dictionary<string, object> with a single key named "myHealthValue".
      m_CurrentHealth = Convert.ToSingle(currentValue.myHealthValue);
      SetHealthUI();
  }

  private void OnDestroy()
  {
      _disposable?.Dispose();
  }
}
```

### Queries

You can make complex declarative queries on the datastore if you want to.

```csharp
using IWorld.ContractDefinition;
using mud.Client;
using mud.Unity;
using UnityEngine;
using ObservableExtensions = UniRx.ObservableExtensions;

void GetPlayersDefeatedMonster(string monsterName) {
  // Find the name of the player that defeated a monster of MonsterName.
  var query = new Query().Find("?playerName")
      .Where("TableId<:Monster>", "?monsterId", "name", monsterName)
      .Where("TableId<:Monster>", "?monsterId", "slayedBy", "?playerId")
      .Where("TableId<:Username>", "?playerId", "username", "?playerName");

  // Execute the query
	var result = NetworkManager.Instance.ds.Query(query);

  // Result returns an IEnumerable of dictionaries
  // where the key is the variable name and the value is the variable value,
  // e.g. [{ playerName: "Bob" }]

  foreach (var record in result) {
    Debug.Log("Found player with name: " + record["playerName"]);
  }
}
```

## Future work

- MODE integration
- Improve performance of Datastore
- SQLite as a backend for persisting the datastore

## License

MIT
